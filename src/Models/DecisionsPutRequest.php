<?php

declare(strict_types=1);

/*
 * Payrix
 *
 * This file was automatically generated by Worldpay.
 */

namespace PayrixLib\Models;

use PayrixLib\ApiHelper;
use stdClass;

class DecisionsPutRequest implements \JsonSerializable
{
    /**
     * @var string|null
     */
    private $login;

    /**
     * @var string|null
     */
    private $org;

    /**
     * @var string|null
     */
    private $entity;

    /**
     * @var string|null
     */
    private $decision;

    /**
     * @var string|null
     */
    private $division;

    /**
     * @var string|null
     */
    private $partition;

    /**
     * @var string|null
     */
    private $application;

    /**
     * @var string|null
     */
    private $level;

    /**
     * @var string|null
     */
    private $type;

    /**
     * @var string|null
     */
    private $target;

    /**
     * @var int|null
     */
    private $action;

    /**
     * @var int|null
     */
    private $sequence;

    /**
     * @var int|null
     */
    private $amount;

    /**
     * @var string|null
     */
    private $value;

    /**
     * @var string|null
     */
    private $period;

    /**
     * @var int|null
     */
    private $periodFactor;

    /**
     * @var string|null
     */
    private $schedule;

    /**
     * @var int|null
     */
    private $scheduleFactor;

    /**
     * @var int|null
     */
    private $start;

    /**
     * @var int|null
     */
    private $finish;

    /**
     * @var int|null
     */
    private $low;

    /**
     * @var int|null
     */
    private $high;

    /**
     * @var int|null
     */
    private $useCache;

    /**
     * @var int|null
     */
    private $cacheTime;

    /**
     * @var int|null
     */
    private $options;

    /**
     * @var int|null
     */
    private $additionalOptions;

    /**
     * @var string|null
     */
    private $errorMessage;

    /**
     * @var string|null
     */
    private $reason;

    /**
     * @var int|null
     */
    private $inactive = InactiveEnum::ACTIVE;

    /**
     * @var int|null
     */
    private $frozen = FrozenEnum::NOTFROZEN;

    /**
     * Returns Login.
     * The identifier of the Login that owns this decisions resource.
     */
    public function getLogin(): ?string
    {
        return $this->login;
    }

    /**
     * Sets Login.
     * The identifier of the Login that owns this decisions resource.
     *
     * @maps login
     */
    public function setLogin(?string $login): void
    {
        $this->login = $login;
    }

    /**
     * Returns Org.
     * If this decision resource relates to an Org, then this field stores the identifier of the Org.
     */
    public function getOrg(): ?string
    {
        return $this->org;
    }

    /**
     * Sets Org.
     * If this decision resource relates to an Org, then this field stores the identifier of the Org.
     *
     * @maps org
     */
    public function setOrg(?string $org): void
    {
        $this->org = $org;
    }

    /**
     * Returns Entity.
     * If this decision resource relates to an Entity, then this field stores the identifier of the Entity.
     */
    public function getEntity(): ?string
    {
        return $this->entity;
    }

    /**
     * Sets Entity.
     * If this decision resource relates to an Entity, then this field stores the identifier of the Entity.
     *
     * @maps entity
     */
    public function setEntity(?string $entity): void
    {
        $this->entity = $entity;
    }

    /**
     * Returns Decision.
     * The identifier of a linked decision resource that acts in coordination with this decision. When you
     * define a decision attribute here, the referenced decision becomes the 'parent' resource. The action
     * field set on the 'parent' resource determines the action that occurs if all of the linked decisions
     * fail.
     */
    public function getDecision(): ?string
    {
        return $this->decision;
    }

    /**
     * Sets Decision.
     * The identifier of a linked decision resource that acts in coordination with this decision. When you
     * define a decision attribute here, the referenced decision becomes the 'parent' resource. The action
     * field set on the 'parent' resource determines the action that occurs if all of the linked decisions
     * fail.
     *
     * @maps decision
     */
    public function setDecision(?string $decision): void
    {
        $this->decision = $decision;
    }

    /**
     * Returns Division.
     * Identifier of the division to which the decision resource belongs.
     */
    public function getDivision(): ?string
    {
        return $this->division;
    }

    /**
     * Sets Division.
     * Identifier of the division to which the decision resource belongs.
     *
     * @maps division
     */
    public function setDivision(?string $division): void
    {
        $this->division = $division;
    }

    /**
     * Returns Partition.
     * Identifier of the partition to which the decision resource belongs.
     */
    public function getPartition(): ?string
    {
        return $this->partition;
    }

    /**
     * Sets Partition.
     * Identifier of the partition to which the decision resource belongs.
     *
     * @maps partition
     */
    public function setPartition(?string $partition): void
    {
        $this->partition = $partition;
    }

    /**
     * Returns Application.
     * Where the action defined by this DecisionAction should apply.
     *
     * <details>
     * <summary>Valid Values</summary>
     *
     * - `account` - **Account type Decision.**
     * - `txn` - **Txn type Decision.**
     * - `entity` - **Entity type Decision.**
     *
     * </details>
     */
    public function getApplication(): ?string
    {
        return $this->application;
    }

    /**
     * Sets Application.
     * Where the action defined by this DecisionAction should apply.
     *
     * <details>
     * <summary>Valid Values</summary>
     *
     * - `account` - **Account type Decision.**
     * - `txn` - **Txn type Decision.**
     * - `entity` - **Entity type Decision.**
     *
     * </details>
     *
     * @maps application
     * @factory \PayrixLib\Models\DecisionActionsApplicationEnum::checkValue
     */
    public function setApplication(?string $application): void
    {
        $this->application = $application;
    }

    /**
     * Returns Level.
     * The levels of decision admin, merchant, division, partition.
     */
    public function getLevel(): ?string
    {
        return $this->level;
    }

    /**
     * Sets Level.
     * The levels of decision admin, merchant, division, partition.
     *
     * @maps level
     */
    public function setLevel(?string $level): void
    {
        $this->level = $level;
    }

    /**
     * Returns Type.
     * The type of check to perform.
     *
     * <details>
     * <summary>Valid Values</summary>
     *
     * - `merchantFailureLimit` - **Exceeded the maximum number of allowed failed authorizations.**
     * - `merchantFailureRatio` - **Exceeded the maximum ratio of allowed failed authorizations.**
     * - `saleTotalLimit` - **Exceeded the maximum allowed sale total value.**
     * - `refundTotalLimit` - **Exceeded the maximum allowed refund total value.**
     * - `averageSaleCountLimit` - **Exceeded the allowed maximum payment size (individual transaction
     * amount).**
     * - `merchantRefundSaleRatio` - **Exceeded the maximum allowed ratio of refunds to sales.**
     * - `merchantPaymentSuccessLimit` - **This is used to check if the merchant has charged the same
     * payment more than X times on a given period of time.**
     * - `ipFailureLimit` - **Exceeded the maximum allowed number of failed authorizations for a particular
     * IP address.**
     * - `ipFailureRatio` - **Exceeded the maximum allowed ratio of failed authorizations for a particular
     * IP address.**
     * - `inactiveMerchant` - **The Merchant is not active.**
     * - `merchantPaymentFailureLimit` - **Exceeded the maximum allowed number of failed transactions.**
     * - `merchantCaptureWithoutAuthLimit` - **Exceeded the maximum allowed number of transactions without
     * authorizations.**
     * - `refundWithoutSale` - **Refund transaction does not have an associated sale transaction.**
     * - `refundWithoutSaleLimit` - **Exceeded the maximum number of refund transactions that do not have
     * associated sale transactions.**
     * - `captureAboveAuthLimit` - **Exceeded the maximum authorized value for transactions with failed
     * authorizations.**
     * - `fraudScore` - **Transaction fraud score.**
     * - `cvv` - **CVV.**
     * - `avs` - **AVS.**
     * - `aavs` - **AAVS.**
     * - `duplicateTxn` - **Duplicate transaction.**
     * - `merchantMatch` - **Transaction matches merchant details.**
     * - `currencyConversion` - **Transaction triggers currency conversion.**
     * - `settledCurrencyMismatch` - **Transaction settled currency mismatch.**
     * - `initialTxn` - **Initial transaction of this type.**
     * - `similarTotalLimit` - **Exceeded the limit of transactions with equal totals.**
     * - `similarTotalRatio` - **Exceeded the ratio of transactions with equal totals.**
     * - `saleTotalMinimum` - **Minimum transaction amount.**
     * - `limit` - **Exceeded the maximum allowed number of authorizations.**
     * - `ratio` - **This is used to check if similar transactions have reached the ratio of auth
     * transactions in a given period of time.**
     * - `txnWatchlist` - **Check the transaction data against a custom watchlist.**
     * - `balanceRefundLimit` - **This is used to check if a merchant has enough balance to process a
     * REFUND transaction and it is within the scope of the threshold.**
     *
     * </details>
     */
    public function getType(): ?string
    {
        return $this->type;
    }

    /**
     * Sets Type.
     * The type of check to perform.
     *
     * <details>
     * <summary>Valid Values</summary>
     *
     * - `merchantFailureLimit` - **Exceeded the maximum number of allowed failed authorizations.**
     * - `merchantFailureRatio` - **Exceeded the maximum ratio of allowed failed authorizations.**
     * - `saleTotalLimit` - **Exceeded the maximum allowed sale total value.**
     * - `refundTotalLimit` - **Exceeded the maximum allowed refund total value.**
     * - `averageSaleCountLimit` - **Exceeded the allowed maximum payment size (individual transaction
     * amount).**
     * - `merchantRefundSaleRatio` - **Exceeded the maximum allowed ratio of refunds to sales.**
     * - `merchantPaymentSuccessLimit` - **This is used to check if the merchant has charged the same
     * payment more than X times on a given period of time.**
     * - `ipFailureLimit` - **Exceeded the maximum allowed number of failed authorizations for a particular
     * IP address.**
     * - `ipFailureRatio` - **Exceeded the maximum allowed ratio of failed authorizations for a particular
     * IP address.**
     * - `inactiveMerchant` - **The Merchant is not active.**
     * - `merchantPaymentFailureLimit` - **Exceeded the maximum allowed number of failed transactions.**
     * - `merchantCaptureWithoutAuthLimit` - **Exceeded the maximum allowed number of transactions without
     * authorizations.**
     * - `refundWithoutSale` - **Refund transaction does not have an associated sale transaction.**
     * - `refundWithoutSaleLimit` - **Exceeded the maximum number of refund transactions that do not have
     * associated sale transactions.**
     * - `captureAboveAuthLimit` - **Exceeded the maximum authorized value for transactions with failed
     * authorizations.**
     * - `fraudScore` - **Transaction fraud score.**
     * - `cvv` - **CVV.**
     * - `avs` - **AVS.**
     * - `aavs` - **AAVS.**
     * - `duplicateTxn` - **Duplicate transaction.**
     * - `merchantMatch` - **Transaction matches merchant details.**
     * - `currencyConversion` - **Transaction triggers currency conversion.**
     * - `settledCurrencyMismatch` - **Transaction settled currency mismatch.**
     * - `initialTxn` - **Initial transaction of this type.**
     * - `similarTotalLimit` - **Exceeded the limit of transactions with equal totals.**
     * - `similarTotalRatio` - **Exceeded the ratio of transactions with equal totals.**
     * - `saleTotalMinimum` - **Minimum transaction amount.**
     * - `limit` - **Exceeded the maximum allowed number of authorizations.**
     * - `ratio` - **This is used to check if similar transactions have reached the ratio of auth
     * transactions in a given period of time.**
     * - `txnWatchlist` - **Check the transaction data against a custom watchlist.**
     * - `balanceRefundLimit` - **This is used to check if a merchant has enough balance to process a
     * REFUND transaction and it is within the scope of the threshold.**
     *
     * </details>
     *
     * @maps type
     * @factory \PayrixLib\Models\DecisionTypeEnum::checkValue
     */
    public function setType(?string $type): void
    {
        $this->type = $type;
    }

    /**
     * Returns Target.
     * The target that this decision should apply at.
     *
     * <details>
     * <summary>Valid Values</summary>
     *
     * - `activation` - **Terminal activation.**
     * - `auth` - **Apply this decision during transaction authorization.**
     * - `postauth` - **Immediately after authorization.**
     * - `capture` - **Apply this decision during transaction capture.**
     * - `refund` - **Apply this decision when processing a refund.**
     * - `createEntity` - **createEntity. Process decisions during entity creation.**
     * - `underwriting` - **Underwriting. Check the members before they are boarded.**
     * - `preboard` - **Preboard. Check the Merchant before they are boarded.**
     * - `postboard` - **Check the Merchant after they are boarded.**
     * - `txn` - **Check the Merchant when they process a Transaction.**
     * - `txnVolume` - **Check the Merchant when their transaction volume hits a certain amount.**
     * - `payout` - **Check the Merchant when a Payout occurs.**
     * - `payoutVolume` - **Check the Merchant when the volume of Payouts to the Merchant hits a certain
     * amount.**
     *
     * </details>
     */
    public function getTarget(): ?string
    {
        return $this->target;
    }

    /**
     * Sets Target.
     * The target that this decision should apply at.
     *
     * <details>
     * <summary>Valid Values</summary>
     *
     * - `activation` - **Terminal activation.**
     * - `auth` - **Apply this decision during transaction authorization.**
     * - `postauth` - **Immediately after authorization.**
     * - `capture` - **Apply this decision during transaction capture.**
     * - `refund` - **Apply this decision when processing a refund.**
     * - `createEntity` - **createEntity. Process decisions during entity creation.**
     * - `underwriting` - **Underwriting. Check the members before they are boarded.**
     * - `preboard` - **Preboard. Check the Merchant before they are boarded.**
     * - `postboard` - **Check the Merchant after they are boarded.**
     * - `txn` - **Check the Merchant when they process a Transaction.**
     * - `txnVolume` - **Check the Merchant when their transaction volume hits a certain amount.**
     * - `payout` - **Check the Merchant when a Payout occurs.**
     * - `payoutVolume` - **Check the Merchant when the volume of Payouts to the Merchant hits a certain
     * amount.**
     *
     * </details>
     *
     * @maps target
     * @factory \PayrixLib\Models\DecisionsTargetEnum::checkValue
     */
    public function setTarget(?string $target): void
    {
        $this->target = $target;
    }

    /**
     * Returns Action.
     * The action to take when this check fails.
     *
     * <details>
     * <summary>Valid Values</summary>
     *
     * - `0` - **No action.**
     * - `1` - **Block txn, will never be processed. The Entity is sent to the manual review queue.**
     * - `3` - **Hold txn, will not be captured.**
     * - `4` - **Reserve txn, funds should be reserved.**
     * - `5` - **Block current activity, no change for merchant.**
     * - `6` - **Passed decision(s). Will not be set anywhere, will only be used for integration purposes.
     * **
     * - `7` - **We did not have policies to process.**
     * - `8` - **We onboard the merchant and wait for manual check later.**
     * - `9` - **Schedule the automatic release of the reserve.**
     * - `10` - **Hold txn, will not be captured. Automatic release when the associated sale is done.**
     *
     * </details>
     */
    public function getAction(): ?int
    {
        return $this->action;
    }

    /**
     * Sets Action.
     * The action to take when this check fails.
     *
     * <details>
     * <summary>Valid Values</summary>
     *
     * - `0` - **No action.**
     * - `1` - **Block txn, will never be processed. The Entity is sent to the manual review queue.**
     * - `3` - **Hold txn, will not be captured.**
     * - `4` - **Reserve txn, funds should be reserved.**
     * - `5` - **Block current activity, no change for merchant.**
     * - `6` - **Passed decision(s). Will not be set anywhere, will only be used for integration purposes.
     * **
     * - `7` - **We did not have policies to process.**
     * - `8` - **We onboard the merchant and wait for manual check later.**
     * - `9` - **Schedule the automatic release of the reserve.**
     * - `10` - **Hold txn, will not be captured. Automatic release when the associated sale is done.**
     *
     * </details>
     *
     * @maps action
     * @factory \PayrixLib\Models\DescisionActionEnum::checkValue
     */
    public function setAction(?int $action): void
    {
        $this->action = $action;
    }

    /**
     * Returns Sequence.
     * A sequence number to use when applying multiple linked decisions: When two or more decisions are
     * linked using their 'decision' fields, the checks with lower 'sequence' numbers are applied first;
     * this field is specified as an integer.
     */
    public function getSequence(): ?int
    {
        return $this->sequence;
    }

    /**
     * Sets Sequence.
     * A sequence number to use when applying multiple linked decisions: When two or more decisions are
     * linked using their 'decision' fields, the checks with lower 'sequence' numbers are applied first;
     * this field is specified as an integer.
     *
     * @maps sequence
     */
    public function setSequence(?int $sequence): void
    {
        $this->sequence = $sequence;
    }

    /**
     * Returns Amount.
     * The minimum value that the Transaction must be to target this decision, The unit of measure is
     * determined by the type of check.
     */
    public function getAmount(): ?int
    {
        return $this->amount;
    }

    /**
     * Sets Amount.
     * The minimum value that the Transaction must be to target this decision, The unit of measure is
     * determined by the type of check.
     *
     * @maps amount
     */
    public function setAmount(?int $amount): void
    {
        $this->amount = $amount;
    }

    /**
     * Returns Value.
     * The amount that the associated Transaction should be compared against. The units for this field
     * depend on the type of check: for checks that are based on a ratio, specify the amount as a
     * percentage in basis points; for checks that are based on a dollar amount, specify the amount in
     * cents; for checks that are based on a count, specify the exact value as an integer.
     */
    public function getValue(): ?string
    {
        return $this->value;
    }

    /**
     * Sets Value.
     * The amount that the associated Transaction should be compared against. The units for this field
     * depend on the type of check: for checks that are based on a ratio, specify the amount as a
     * percentage in basis points; for checks that are based on a dollar amount, specify the amount in
     * cents; for checks that are based on a count, specify the exact value as an integer.
     *
     * @maps value
     */
    public function setValue(?string $value): void
    {
        $this->value = $value;
    }

    /**
     * Returns Period.
     * A date indicator that determines how far back in time time-based checks should be checked. This
     * field works in conjunction with the 'periodFactor' field, which multiplies this basic period.
     *
     * <details>
     * <summary>Valid Values</summary>
     *
     * - `days` - **Days. The basic value for the date range is set in days.**
     * - `weeks` - **Weeks. The basic value for the date range is set in weeks.**
     * - `months` - **Months. The basic value for the date range is set in months.**
     * - `years` - **Years. The basic value for the date range is set in years.**
     * - `seconds` - **Seconds. The basic value for the date range is set in seconds.**
     * - `minutes` - **Minutes. The basic value for the date range is set in minutes.**
     * - `hours` - **Hours. The basic value for the date range is set in hours.**
     *
     * </details>
     */
    public function getPeriod(): ?string
    {
        return $this->period;
    }

    /**
     * Sets Period.
     * A date indicator that determines how far back in time time-based checks should be checked. This
     * field works in conjunction with the 'periodFactor' field, which multiplies this basic period.
     *
     * <details>
     * <summary>Valid Values</summary>
     *
     * - `days` - **Days. The basic value for the date range is set in days.**
     * - `weeks` - **Weeks. The basic value for the date range is set in weeks.**
     * - `months` - **Months. The basic value for the date range is set in months.**
     * - `years` - **Years. The basic value for the date range is set in years.**
     * - `seconds` - **Seconds. The basic value for the date range is set in seconds.**
     * - `minutes` - **Minutes. The basic value for the date range is set in minutes.**
     * - `hours` - **Hours. The basic value for the date range is set in hours.**
     *
     * </details>
     *
     * @maps period
     * @factory \PayrixLib\Models\DecisionsPeriodEnum::checkValue
     */
    public function setPeriod(?string $period): void
    {
        $this->period = $period;
    }

    /**
     * Returns Period Factor.
     * A multiplier that you can use to adjust the basic date range set in the 'period' field, such as
     * daily, weekly, monthly, or annually; this field is specified as an integer and its value determines
     * how the interval is multiplied.
     */
    public function getPeriodFactor(): ?int
    {
        return $this->periodFactor;
    }

    /**
     * Sets Period Factor.
     * A multiplier that you can use to adjust the basic date range set in the 'period' field, such as
     * daily, weekly, monthly, or annually; this field is specified as an integer and its value determines
     * how the interval is multiplied.
     *
     * @maps periodFactor
     */
    public function setPeriodFactor(?int $periodFactor): void
    {
        $this->periodFactor = $periodFactor;
    }

    /**
     * Returns Schedule.
     * The schedule that determines when this Decision is triggered to check entities.
     */
    public function getSchedule(): ?string
    {
        return $this->schedule;
    }

    /**
     * Sets Schedule.
     * The schedule that determines when this Decision is triggered to check entities.
     *
     * @maps schedule
     */
    public function setSchedule(?string $schedule): void
    {
        $this->schedule = $schedule;
    }

    /**
     * Returns Schedule Factor.
     * A multiplier that you can use to adjust the schedule set in the 'schedule' field, if it is set to a
     * duration-based trigger, such as daily, weekly, monthly, or annually. This field is specified as an
     * integer and its value determines how the interval is multiplied.
     */
    public function getScheduleFactor(): ?int
    {
        return $this->scheduleFactor;
    }

    /**
     * Sets Schedule Factor.
     * A multiplier that you can use to adjust the schedule set in the 'schedule' field, if it is set to a
     * duration-based trigger, such as daily, weekly, monthly, or annually. This field is specified as an
     * integer and its value determines how the interval is multiplied.
     *
     * @maps scheduleFactor
     */
    public function setScheduleFactor(?int $scheduleFactor): void
    {
        $this->scheduleFactor = $scheduleFactor;
    }

    /**
     * Returns Start.
     * The date on which checking of the Decision should start is specified as an eight digit string in
     * YYYYMMDD format, for example, '20160120' for January 20, 2016; the value of this field must
     * represent a date in the future, or the present date.
     */
    public function getStart(): ?int
    {
        return $this->start;
    }

    /**
     * Sets Start.
     * The date on which checking of the Decision should start is specified as an eight digit string in
     * YYYYMMDD format, for example, '20160120' for January 20, 2016; the value of this field must
     * represent a date in the future, or the present date.
     *
     * @maps start
     */
    public function setStart(?int $start): void
    {
        $this->start = $start;
    }

    /**
     * Returns Finish.
     * The date on which checking of the Decision should end. The date is specified as an eight digit
     * string in YYYYMMDD format, for example, '20160120' for January 20, 2016. The value of this field
     * must represent a date in the future.
     */
    public function getFinish(): ?int
    {
        return $this->finish;
    }

    /**
     * Sets Finish.
     * The date on which checking of the Decision should end. The date is specified as an eight digit
     * string in YYYYMMDD format, for example, '20160120' for January 20, 2016. The value of this field
     * must represent a date in the future.
     *
     * @maps finish
     */
    public function setFinish(?int $finish): void
    {
        $this->finish = $finish;
    }

    /**
     * Returns Low.
     * A lower cut-off value for the score in this decision; the check fails if the score is equal to or
     * below this value.
     */
    public function getLow(): ?int
    {
        return $this->low;
    }

    /**
     * Sets Low.
     * A lower cut-off value for the score in this decision; the check fails if the score is equal to or
     * below this value.
     *
     * @maps low
     */
    public function setLow(?int $low): void
    {
        $this->low = $low;
    }

    /**
     * Returns High.
     * An upper cut-off value for the score in this decision; the check fails if the score is equal to or
     * above this value.
     */
    public function getHigh(): ?int
    {
        return $this->high;
    }

    /**
     * Sets High.
     * An upper cut-off value for the score in this decision; the check fails if the score is equal to or
     * above this value.
     *
     * @maps high
     */
    public function setHigh(?int $high): void
    {
        $this->high = $high;
    }

    /**
     * Returns Use Cache.
     * Whether to check for and use existing Verifications and Verification Results for this decision.
     *
     * <details>
     * <summary>Valid Values</summary>
     *
     * - `0` - **Disabled**
     * - `1` - **Enabled**
     *
     * </details>
     */
    public function getUseCache(): ?int
    {
        return $this->useCache;
    }

    /**
     * Sets Use Cache.
     * Whether to check for and use existing Verifications and Verification Results for this decision.
     *
     * <details>
     * <summary>Valid Values</summary>
     *
     * - `0` - **Disabled**
     * - `1` - **Enabled**
     *
     * </details>
     *
     * @maps useCache
     * @factory \PayrixLib\Models\DecisionsUseCacheEnum::checkValue
     */
    public function setUseCache(?int $useCache): void
    {
        $this->useCache = $useCache;
    }

    /**
     * Returns Cache Time.
     * The time caching limit to check for existing verification.
     */
    public function getCacheTime(): ?int
    {
        return $this->cacheTime;
    }

    /**
     * Sets Cache Time.
     * The time caching limit to check for existing verification.
     *
     * @maps cacheTime
     */
    public function setCacheTime(?int $cacheTime): void
    {
        $this->cacheTime = $cacheTime;
    }

    /**
     * Returns Options.
     * The options for the Verification are specified as a sum of the desired options.
     */
    public function getOptions(): ?int
    {
        return $this->options;
    }

    /**
     * Sets Options.
     * The options for the Verification are specified as a sum of the desired options.
     *
     * @maps options
     */
    public function setOptions(?int $options): void
    {
        $this->options = $options;
    }

    /**
     * Returns Additional Options.
     * The additionalOptions for the Verification are specified as a sum of the desired options.
     */
    public function getAdditionalOptions(): ?int
    {
        return $this->additionalOptions;
    }

    /**
     * Sets Additional Options.
     * The additionalOptions for the Verification are specified as a sum of the desired options.
     *
     * @maps additionalOptions
     */
    public function setAdditionalOptions(?int $additionalOptions): void
    {
        $this->additionalOptions = $additionalOptions;
    }

    /**
     * Returns Error Message.
     * The error message for the decision: If the field is null the error message will be a generic failure
     * message, if the field is empty the error message will be a specific error message, if the field is
     * set to a string the error message will be that string.
     */
    public function getErrorMessage(): ?string
    {
        return $this->errorMessage;
    }

    /**
     * Sets Error Message.
     * The error message for the decision: If the field is null the error message will be a generic failure
     * message, if the field is empty the error message will be a specific error message, if the field is
     * set to a string the error message will be that string.
     *
     * @maps errorMessage
     */
    public function setErrorMessage(?string $errorMessage): void
    {
        $this->errorMessage = $errorMessage;
    }

    /**
     * Returns Reason.
     * The reason for the decision. If the field is null the error message will be a generic message, if
     * the field is set to a string the reason message will be that string.
     */
    public function getReason(): ?string
    {
        return $this->reason;
    }

    /**
     * Sets Reason.
     * The reason for the decision. If the field is null the error message will be a generic message, if
     * the field is set to a string the reason message will be that string.
     *
     * @maps reason
     */
    public function setReason(?string $reason): void
    {
        $this->reason = $reason;
    }

    /**
     * Returns Inactive.
     * Whether this resource is marked as inactive.
     *
     * <details>
     * <summary>Valid Values</summary>
     *
     * - `0` - **Active**
     * - `1` - **Inactive**
     *
     * </details>
     */
    public function getInactive(): ?int
    {
        return $this->inactive;
    }

    /**
     * Sets Inactive.
     * Whether this resource is marked as inactive.
     *
     * <details>
     * <summary>Valid Values</summary>
     *
     * - `0` - **Active**
     * - `1` - **Inactive**
     *
     * </details>
     *
     * @maps inactive
     * @factory \PayrixLib\Models\InactiveEnum::checkValue
     */
    public function setInactive(?int $inactive): void
    {
        $this->inactive = $inactive;
    }

    /**
     * Returns Frozen.
     * Whether this resource is marked as frozen.
     *
     * <details>
     * <summary>Valid Values</summary>
     *
     * - `0` - **Not Frozen**
     * - `1` - **Frozen**
     *
     * </details>
     */
    public function getFrozen(): ?int
    {
        return $this->frozen;
    }

    /**
     * Sets Frozen.
     * Whether this resource is marked as frozen.
     *
     * <details>
     * <summary>Valid Values</summary>
     *
     * - `0` - **Not Frozen**
     * - `1` - **Frozen**
     *
     * </details>
     *
     * @maps frozen
     * @factory \PayrixLib\Models\FrozenEnum::checkValue
     */
    public function setFrozen(?int $frozen): void
    {
        $this->frozen = $frozen;
    }

    /**
     * Converts the DecisionsPutRequest object to a human-readable string representation.
     *
     * @return string The string representation of the DecisionsPutRequest object.
     */
    public function __toString(): string
    {
        return ApiHelper::stringify(
            'DecisionsPutRequest',
            [
                'login' => $this->login,
                'org' => $this->org,
                'entity' => $this->entity,
                'decision' => $this->decision,
                'division' => $this->division,
                'partition' => $this->partition,
                'application' => $this->application,
                'level' => $this->level,
                'type' => $this->type,
                'target' => $this->target,
                'action' => $this->action,
                'sequence' => $this->sequence,
                'amount' => $this->amount,
                'value' => $this->value,
                'period' => $this->period,
                'periodFactor' => $this->periodFactor,
                'schedule' => $this->schedule,
                'scheduleFactor' => $this->scheduleFactor,
                'start' => $this->start,
                'finish' => $this->finish,
                'low' => $this->low,
                'high' => $this->high,
                'useCache' => $this->useCache,
                'cacheTime' => $this->cacheTime,
                'options' => $this->options,
                'additionalOptions' => $this->additionalOptions,
                'errorMessage' => $this->errorMessage,
                'reason' => $this->reason,
                'inactive' => $this->inactive,
                'frozen' => $this->frozen
            ]
        );
    }

    /**
     * Encode this object to JSON
     *
     * @param bool $asArrayWhenEmpty Whether to serialize this model as an array whenever no fields
     *        are set. (default: false)
     *
     * @return array|stdClass
     */
    #[\ReturnTypeWillChange] // @phan-suppress-current-line PhanUndeclaredClassAttribute for (php < 8.1)
    public function jsonSerialize(bool $asArrayWhenEmpty = false)
    {
        $json = [];
        if (isset($this->login)) {
            $json['login']             = $this->login;
        }
        if (isset($this->org)) {
            $json['org']               = $this->org;
        }
        if (isset($this->entity)) {
            $json['entity']            = $this->entity;
        }
        if (isset($this->decision)) {
            $json['decision']          = $this->decision;
        }
        if (isset($this->division)) {
            $json['division']          = $this->division;
        }
        if (isset($this->partition)) {
            $json['partition']         = $this->partition;
        }
        if (isset($this->application)) {
            $json['application']       = DecisionActionsApplicationEnum::checkValue($this->application);
        }
        if (isset($this->level)) {
            $json['level']             = $this->level;
        }
        if (isset($this->type)) {
            $json['type']              = DecisionTypeEnum::checkValue($this->type);
        }
        if (isset($this->target)) {
            $json['target']            = DecisionsTargetEnum::checkValue($this->target);
        }
        if (isset($this->action)) {
            $json['action']            = DescisionActionEnum::checkValue($this->action);
        }
        if (isset($this->sequence)) {
            $json['sequence']          = $this->sequence;
        }
        if (isset($this->amount)) {
            $json['amount']            = $this->amount;
        }
        if (isset($this->value)) {
            $json['value']             = $this->value;
        }
        if (isset($this->period)) {
            $json['period']            = DecisionsPeriodEnum::checkValue($this->period);
        }
        if (isset($this->periodFactor)) {
            $json['periodFactor']      = $this->periodFactor;
        }
        if (isset($this->schedule)) {
            $json['schedule']          = $this->schedule;
        }
        if (isset($this->scheduleFactor)) {
            $json['scheduleFactor']    = $this->scheduleFactor;
        }
        if (isset($this->start)) {
            $json['start']             = $this->start;
        }
        if (isset($this->finish)) {
            $json['finish']            = $this->finish;
        }
        if (isset($this->low)) {
            $json['low']               = $this->low;
        }
        if (isset($this->high)) {
            $json['high']              = $this->high;
        }
        if (isset($this->useCache)) {
            $json['useCache']          = DecisionsUseCacheEnum::checkValue($this->useCache);
        }
        if (isset($this->cacheTime)) {
            $json['cacheTime']         = $this->cacheTime;
        }
        if (isset($this->options)) {
            $json['options']           = $this->options;
        }
        if (isset($this->additionalOptions)) {
            $json['additionalOptions'] = $this->additionalOptions;
        }
        if (isset($this->errorMessage)) {
            $json['errorMessage']      = $this->errorMessage;
        }
        if (isset($this->reason)) {
            $json['reason']            = $this->reason;
        }
        if (isset($this->inactive)) {
            $json['inactive']          = InactiveEnum::checkValue($this->inactive);
        }
        if (isset($this->frozen)) {
            $json['frozen']            = FrozenEnum::checkValue($this->frozen);
        }

        return (!$asArrayWhenEmpty && empty($json)) ? new stdClass() : $json;
    }
}
